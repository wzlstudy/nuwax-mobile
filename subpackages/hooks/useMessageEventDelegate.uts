import { ref, onMounted, onUnmounted, Ref } from 'vue'
import { EventBindResponseActionEnum } from '@/types/enums/agent'
import { checkPathParams, fillPathParams, objectToQueryString } from '@/utils/common.uts'
import { EventBindConfig, ShowPagePreviewOptions } from '@/types/interfaces/agent'
import { API_BASE_URL } from '@/constants/config'
import { handleExternalLink } from '@/utils/system.uts'

// ============ å·¥å…·æ–¹æ³• ============
const showError = (msg: string): void => {
  uni.showToast({
    title: msg,
    icon: 'none'
  })
}

// ============ é˜²é‡å¤è§¦å‘ç®¡ç†å™¨ ============

/**
 * äº‹ä»¶é˜²é‡å¤è§¦å‘ç®¡ç†å™¨
 * ç”¨äºé˜²æ­¢çŸ­æ—¶é—´å†…é‡å¤è§¦å‘ç›¸åŒçš„äº‹ä»¶
 */
export class EventDedupManager {
  private handledEvents: Set<string> = new Set()
  private timeout: number = 1000

  constructor(timeout?: number) {
    if (timeout !== undefined) {
      this.timeout = timeout
    }
  }

  /**
   * æ£€æŸ¥äº‹ä»¶æ˜¯å¦å·²ç»è¢«å¤„ç†
   * @param eventKey äº‹ä»¶é”®
   * @returns æ˜¯å¦å·²å¤„ç†ï¼ˆtrue è¡¨ç¤ºå·²å¤„ç†ï¼Œåº”è¯¥è·³è¿‡ï¼‰
   */
  isDuplicate(eventKey: string): boolean {
    if (this.handledEvents.has(eventKey)) {
      return true
    }
    this.handledEvents.add(eventKey)
    setTimeout(() => {
      this.handledEvents.delete(eventKey)
    }, this.timeout)
    return false
  }

  /**
   * æ¸…é™¤æ‰€æœ‰è®°å½•
   */
  clear(): void {
    this.handledEvents.clear()
  }
}

// ============ å¯¼å‡ºçš„äº‹ä»¶å¤„ç†å‡½æ•° ============

/**
 * å¤„ç†æ¶ˆæ¯äº‹ä»¶ç‚¹å‡»
 * å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ç‹¬ç«‹è°ƒç”¨æ­¤å‡½æ•°æ¥å¤„ç†äº‹ä»¶
 * 
 * @param eventType äº‹ä»¶ç±»å‹æ ‡è¯†
 * @param dataStr äº‹ä»¶æ•°æ®ï¼ˆJSON å­—ç¬¦ä¸²ï¼‰
 * @param eventBindConfig äº‹ä»¶ç»‘å®šé…ç½®
 * @param showPagePreview é¡µé¢é¢„è§ˆå›è°ƒå‡½æ•°
 * @param dedupManager é˜²é‡å¤è§¦å‘ç®¡ç†å™¨ï¼ˆå¯é€‰ï¼‰
 */
export const handleMessageEventClick = (
  eventType: string,
  dataStr: string,
  eventBindConfig: EventBindConfig | undefined,
  showPagePreview?: (opts: ShowPagePreviewOptions) => void,
  dedupManager?: EventDedupManager
): void => {
  const eventKey = `${eventType}-${dataStr}`

  // é˜²é‡å¤è§¦å‘
  if (dedupManager && dedupManager.isDuplicate(eventKey)) {
    return
  }


  // è§£ææ•°æ®
  let parsedData: Record<string, any> = {}
  try {
    parsedData = JSON.parse(dataStr)
  } catch (err) {
    console.error('[Event Handler] æ•°æ®è§£æå¤±è´¥:', err)
    return
  }

  // æŸ¥æ‰¾äº‹ä»¶é…ç½®
  const eventConfig = eventBindConfig?.eventConfigs?.find(
    (cfg) => cfg.identification === eventType
  )
  if (!eventConfig) {
    console.warn(`[Event Handler] æœªæ‰¾åˆ°äº‹ä»¶é…ç½®: ${eventType}`)
    return
  }


  // === æ ¹æ®ç±»å‹æ‰§è¡Œ ===
  switch (eventConfig.type) {
    case EventBindResponseActionEnum.Page: {
      if (!eventConfig.pageUrl) {
        showError('é¡µé¢è·¯å¾„é…ç½®é”™è¯¯')
        return
      }

      const pathParams: Record<string, any> = {}
      const params: Record<string, any> = {}

      eventConfig.args?.forEach((arg) => {
        if (arg.inputType === 'Path' && arg.name)
          pathParams[arg.name] = parsedData[arg.name] ?? arg.bindValue
        if (arg.inputType === 'Query' && arg.name)
          params[arg.name] = parsedData[arg.name] ?? arg.bindValue
      })

      if (checkPathParams(eventConfig.pageUrl, pathParams)) {
        const pageUrl = fillPathParams(eventConfig.pageUrl, pathParams)
        const fullUri = eventConfig.basePath? `${eventConfig.basePath}${pageUrl}`: pageUrl

        // æ„å»ºæŸ¥è¯¢å­—ç¬¦ä¸²
        const queryString = objectToQueryString(params)
        
        showPagePreview?.({
          uri: queryString ? `${fullUri}?${queryString}` : fullUri,
        })
      } else {
        showError('é¡µé¢è·¯å¾„å‚æ•°é…ç½®é”™è¯¯')
      }
      break
    }

    case EventBindResponseActionEnum.Link: {
      handleExternalLink(eventConfig.url)
      break
    }

    default:
      console.warn(`[Event Handler] æœªçŸ¥çš„äº‹ä»¶ç±»å‹: ${eventConfig.type}`)
  }
}

// ============ ä¸» Hook ============

export const useMessageEventDelegate = (
  containerRef: Ref<HTMLElement | null>,
  eventBindConfig?: EventBindConfig,
  showPagePreview?: (opts: ShowPagePreviewOptions) => void
) => {
  // åˆ›å»ºé˜²é‡å¤è§¦å‘ç®¡ç†å™¨
  const dedupManager = new EventDedupManager(1000)

  // ğŸ‘‰ ç‚¹å‡»äº‹ä»¶å¤„ç†ï¼ˆå†…éƒ¨å°è£…ï¼‰
  const handleEventClick = (eventType: string, dataStr: string): void => {
    handleMessageEventClick(
      eventType,
      dataStr,
      eventBindConfig.value,
      showPagePreview,
      dedupManager
    )
  }

  // ğŸ‘‰ ç›‘å¬å®¹å™¨ç‚¹å‡»äº‹ä»¶ï¼ˆä»…H5å¹³å°ï¼‰
  // #ifdef H5 || WEB
  const handleClick = (e: MouseEvent): void => {
    const target = e.target as HTMLElement
    const eventElement = target.closest('.event') as HTMLElement | null

    if (eventElement) {
      e.preventDefault()
      e.stopPropagation()
      const eventType = eventElement.getAttribute('event-type')
      const dataStr = eventElement.getAttribute('data')
      if (eventType && dataStr) {
        handleEventClick(eventType, dataStr)
      } else {
        console.warn('[Event Delegate] ç¼ºå°‘å¿…è¦å±æ€§', { eventType, dataStr })
      }
    }
  }

  // ğŸ‘‰ ç”Ÿå‘½å‘¨æœŸæŒ‚è½½ä¸æ¸…ç†
  onMounted(() => {
    const container = containerRef.value
    if (container) {
      container.addEventListener('click', handleClick)
    }
  })

  onUnmounted(() => {
    const container = containerRef.value
    if (container) {
      container.removeEventListener('click', handleClick)
    }
  })
  // #endif

}
